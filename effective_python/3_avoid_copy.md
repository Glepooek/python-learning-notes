### 避免使用可变数据类型浅拷贝

```python
a = {'1': "one", '2': 'two'}
```

现在，假设想把这个字典用在别的地方，并保持它的初始数据完整。

```python
b = a

b['3'] = 'three'

print(a)
print(b)

# 输出结果
{'1': "one", '2': 'two', '3': 'three'}
{'1': "one", '2': 'two', '3': 'three'}
```

结果本想改变b，而a也被改变了。回想一下，看看其它不可变类型在这种情况下会发生什么，例如一个元组：

```python
c = (2, 3)
d = c
d = (4, 5)

print(c)
print(d)

# 输出结果
(2, 3)
(4, 5)
```

这个结果如我们所料。那么，在之前的例子中到底发生了什么？在上面的代码中，令b = a，表达的意思是：b成为a的一个引用。
它们都指向Python内存中的同一个对象。列表也会发生同样的事，那么该如何解决呢？这必须非常小心。如果真的需要复制一个列表进行处理，
可以这样做：

b = a[:]或b = a.copy()

这将遍历并复制列表中的每个对象的引用，并且把它放在一个新的列表中。但是要注意：```如果列表中存在可变对象，该可变对象
将再次获得它的引用，而不是完整的副本。这就是浅拷贝，深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用```